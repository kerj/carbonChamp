{"ast":null,"code":"var _jsxFileName = \"/Users/kerj/Projects/gql-hasura/src/Context/DataContext.tsx\",\n  _s = $RefreshSig$();\nimport { createContext, useReducer, useCallback, useEffect } from \"react\";\nimport axios from 'axios';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst dataReducer = (state, action) => {\n  switch (action.type) {\n    case 'fetchStarted':\n      return {\n        ...state,\n        isLoading: true,\n        error: null\n      };\n    case 'fetchSuccess':\n      return {\n        ...state,\n        isLoading: false,\n        error: null,\n        data: action.data,\n        stale: false\n      };\n    case 'fetchError':\n      return {\n        ...state,\n        isLoading: false,\n        error: action.error\n      };\n    case 'isStale':\n      console.log('stale');\n      return {\n        ...state,\n        stale: true\n      };\n    default:\n      throw new Error(`Unhandled action type: ${action}`);\n  }\n};\nexport const DataContext = /*#__PURE__*/createContext({\n  data: null,\n  isLoading: false,\n  error: null,\n  setStale: function () {\n    throw new Error(\"Function not implemented.\");\n  }\n});\nexport const DataProvider = _ref => {\n  _s();\n  let {\n    requestMetas,\n    requestHook,\n    children,\n    initialData\n  } = _ref;\n  const [state, dispatch] = useReducer(dataReducer, {\n    data: null,\n    isLoading: false,\n    error: null,\n    stale: true\n  });\n  const handleStale = () => {\n    dispatch({\n      type: 'isStale'\n    });\n  };\n  if (requestHook) {\n    const {\n      data\n    } = requestHook({\n      fetchPolicy: 'network-only'\n    });\n    dispatch({\n      type: \"fetchSuccess\",\n      data\n    });\n  }\n  const fetchData = useCallback(async signal => {\n    dispatch({\n      type: \"fetchStarted\"\n    });\n    try {\n      console.log('trying');\n      if (requestMetas) {\n        const result = await axios(requestMetas.url, {\n          ...requestMetas.options,\n          signal\n        }).then(res => {\n          return res.data;\n        });\n        dispatch({\n          type: \"fetchSuccess\",\n          data: result\n        });\n      }\n    } catch (e) {\n      console.log('error');\n      dispatch({\n        type: \"fetchError\",\n        error: e\n      });\n    }\n  }, [, requestMetas]);\n  useEffect(() => {\n    const abortController = new AbortController();\n    const signal = abortController.signal;\n    if (state.stale === true) {\n      fetchData(signal);\n    }\n    return () => {\n      abortController.abort();\n    };\n  }, [fetchData, state.stale]);\n  return /*#__PURE__*/_jsxDEV(DataContext.Provider, {\n    value: {\n      ...state,\n      setStale: handleStale\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 107,\n    columnNumber: 5\n  }, this);\n};\n_s(DataProvider, \"ZqvlGXGceG6a5yG4qQ49QdpSTtg=\");\n_c = DataProvider;\nvar _c;\n$RefreshReg$(_c, \"DataProvider\");","map":{"version":3,"names":["createContext","useReducer","useCallback","useEffect","axios","dataReducer","state","action","type","isLoading","error","data","stale","console","log","Error","DataContext","setStale","DataProvider","requestMetas","requestHook","children","initialData","dispatch","handleStale","fetchPolicy","fetchData","signal","result","url","options","then","res","e","abortController","AbortController","abort"],"sources":["/Users/kerj/Projects/gql-hasura/src/Context/DataContext.tsx"],"sourcesContent":["import { createContext, useReducer, useCallback, useEffect } from \"react\";\nimport axios from 'axios'\n\ntype DataProviderProps<T> = {\n  requestMetas?: { url: string, options: any };\n  requestHook: any;\n  children: JSX.Element;\n  initialData?: T;\n}\n\nexport type DataState<T> = {\n  data: T | null\n  isLoading: boolean,\n  error: Error | null,\n  stale: boolean\n}\n\nexport type DataActions<T> =\n  | { type: 'fetchStarted' }\n  | { type: 'fetchSuccess'; data: T; }\n  | { type: 'fetchError'; error: Error; }\n  | { type: 'isStale'; };\n\n// need to pass this T value\ntype DataContextValue<T> = {\n  data: DataState<T>['data'],\n  isLoading: DataState<T>['isLoading'],\n  error: DataState<T>['error'],\n  setStale: () => void,\n}\n\nconst dataReducer = <T,>(state: DataState<T>, action: DataActions<T>): DataState<T> => {\n  switch (action.type) {\n    case 'fetchStarted':\n      return { ...state, isLoading: true, error: null }\n    case 'fetchSuccess':\n      return { ...state, isLoading: false, error: null, data: action.data, stale: false };\n    case 'fetchError':\n      return { ...state, isLoading: false, error: action.error }\n    case 'isStale':\n      console.log('stale')\n      return { ...state, stale: true }\n    default:\n      throw new Error(`Unhandled action type: ${action}`)\n  }\n}\n\nexport const DataContext = createContext<DataContextValue<any>>({\n  data: null,\n  isLoading: false,\n  error: null,\n  setStale: function (): void {\n    throw new Error(\"Function not implemented.\");\n  }\n})\n\nexport const DataProvider = <T,>({ requestMetas, requestHook, children, initialData }: DataProviderProps<T>) => {\n  const [state, dispatch] = useReducer(dataReducer, {\n    data: null,\n    isLoading: false,\n    error: null,\n    stale: true,\n  });\n\n\n  const handleStale = () => {\n    dispatch({type:'isStale'})\n  }\n\n  if (requestHook) {\n    const { data } = requestHook({\n      fetchPolicy: 'network-only',\n    })\n    dispatch({ type: \"fetchSuccess\", data });\n  }\n\n  const fetchData = useCallback(async (signal: AbortSignal) => {\n    dispatch({ type: \"fetchStarted\" });\n    try {\n      console.log('trying')\n      if (requestMetas) {\n        const result = await axios(requestMetas.url, { ...requestMetas.options, signal }).then(res => {\n          return res.data\n        });\n        dispatch({ type: \"fetchSuccess\", data: result });\n      }\n    } catch (e) {\n      console.log('error')\n      dispatch({ type: \"fetchError\", error: e as Error })\n    }\n\n  }, [, requestMetas])\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const signal = abortController.signal;\n    if (state.stale === true) {\n      fetchData(signal);\n    }\n    return () => {\n      abortController.abort();\n    }\n  }, [fetchData, state.stale])\n\n\n  return (\n    <DataContext.Provider value={{ ...state, setStale: handleStale } }>{children}</DataContext.Provider>\n  )\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}