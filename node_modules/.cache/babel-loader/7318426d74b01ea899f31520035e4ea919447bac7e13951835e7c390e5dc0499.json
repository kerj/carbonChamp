{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nconst defaultOptions = {};\n/** All built-in and custom scalars, mapped to their actual values */\n\nexport const MyMutationDocument = gql`\n    mutation MyMutation($customer_id: String, $email_address: String, $last_name: String, $first_name: String) {\n  insert_customers_one(\n    object: {email_address: $email_address, customer_id: $customer_id, last_name: $last_name, first_name: $first_name}\n  ) {\n    email_address\n    first_name\n    last_name\n  }\n}\n    `;\n/**\n * __useMyMutationMutation__\n *\n * To run a mutation, you first call `useMyMutationMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useMyMutationMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [myMutationMutation, { data, loading, error }] = useMyMutationMutation({\n *   variables: {\n *      customer_id: // value for 'customer_id'\n *      email_address: // value for 'email_address'\n *      last_name: // value for 'last_name'\n *      first_name: // value for 'first_name'\n *   },\n * });\n */\nexport function useMyMutationMutation(baseOptions) {\n  _s();\n  const options = {\n    ...defaultOptions,\n    ...baseOptions\n  };\n  return Apollo.useMutation(MyMutationDocument, options);\n}\n_s(useMyMutationMutation, \"wwwtpB20p0aLiHIvSy5P98MwIUg=\", false, function () {\n  return [Apollo.useMutation];\n});\nexport const DeleteCustomerByPkDocument = gql`\n    mutation DeleteCustomerByPK($customer_id: String!) {\n  delete_customers_by_pk(customer_id: $customer_id) {\n    email_address\n    first_name\n    last_name\n  }\n}\n    `;\n/**\n * __useDeleteCustomerByPkMutation__\n *\n * To run a mutation, you first call `useDeleteCustomerByPkMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteCustomerByPkMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteCustomerByPkMutation, { data, loading, error }] = useDeleteCustomerByPkMutation({\n *   variables: {\n *      customer_id: // value for 'customer_id'\n *   },\n * });\n */\nexport function useDeleteCustomerByPkMutation(baseOptions) {\n  _s2();\n  const options = {\n    ...defaultOptions,\n    ...baseOptions\n  };\n  return Apollo.useMutation(DeleteCustomerByPkDocument, options);\n}\n_s2(useDeleteCustomerByPkMutation, \"wwwtpB20p0aLiHIvSy5P98MwIUg=\", false, function () {\n  return [Apollo.useMutation];\n});\nexport const GetCustomersLikeNameDocument = gql`\n    query GetCustomersLikeName($limit: Int, $first_name_term: String) {\n  customers(limit: $limit, where: {first_name: {_like: $first_name_term}}) {\n    email_address\n    first_name\n    last_name\n  }\n}\n    `;\n\n/**\n * __useGetCustomersLikeNameQuery__\n *\n * To run a query within a React component, call `useGetCustomersLikeNameQuery` and pass it any options that fit your needs.\n * When your component renders, `useGetCustomersLikeNameQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGetCustomersLikeNameQuery({\n *   variables: {\n *      limit: // value for 'limit'\n *      first_name_term: // value for 'first_name_term'\n *   },\n * });\n */\nexport function useGetCustomersLikeNameQuery(baseOptions) {\n  _s3();\n  const options = {\n    ...defaultOptions,\n    ...baseOptions\n  };\n  return Apollo.useQuery(GetCustomersLikeNameDocument, options);\n}\n_s3(useGetCustomersLikeNameQuery, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [Apollo.useQuery];\n});\nexport function useGetCustomersLikeNameLazyQuery(baseOptions) {\n  _s4();\n  const options = {\n    ...defaultOptions,\n    ...baseOptions\n  };\n  return Apollo.useLazyQuery(GetCustomersLikeNameDocument, options);\n}\n_s4(useGetCustomersLikeNameLazyQuery, \"On+3mFuZjiEOS3MQLgFXtHkppJ4=\", false, function () {\n  return [Apollo.useLazyQuery];\n});","map":{"version":3,"names":["gql","Apollo","defaultOptions","MyMutationDocument","useMyMutationMutation","baseOptions","options","useMutation","DeleteCustomerByPkDocument","useDeleteCustomerByPkMutation","GetCustomersLikeNameDocument","useGetCustomersLikeNameQuery","useQuery","useGetCustomersLikeNameLazyQuery","useLazyQuery"],"sources":["/Users/kerj/Projects/gql-hasura/src/generated/graphql.tsx"],"sourcesContent":["import { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nconst defaultOptions = {} as const;\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  bigint: any;\n  date: any;\n  numeric: any;\n};\n\n/** Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'. */\nexport type Int_Comparison_Exp = {\n  _eq?: InputMaybe<Scalars['Int']>;\n  _gt?: InputMaybe<Scalars['Int']>;\n  _gte?: InputMaybe<Scalars['Int']>;\n  _in?: InputMaybe<Array<Scalars['Int']>>;\n  _is_null?: InputMaybe<Scalars['Boolean']>;\n  _lt?: InputMaybe<Scalars['Int']>;\n  _lte?: InputMaybe<Scalars['Int']>;\n  _neq?: InputMaybe<Scalars['Int']>;\n  _nin?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'. */\nexport type String_Comparison_Exp = {\n  _eq?: InputMaybe<Scalars['String']>;\n  _gt?: InputMaybe<Scalars['String']>;\n  _gte?: InputMaybe<Scalars['String']>;\n  /** does the column match the given case-insensitive pattern */\n  _ilike?: InputMaybe<Scalars['String']>;\n  _in?: InputMaybe<Array<Scalars['String']>>;\n  /** does the column match the given POSIX regular expression, case insensitive */\n  _iregex?: InputMaybe<Scalars['String']>;\n  _is_null?: InputMaybe<Scalars['Boolean']>;\n  /** does the column match the given pattern */\n  _like?: InputMaybe<Scalars['String']>;\n  _lt?: InputMaybe<Scalars['String']>;\n  _lte?: InputMaybe<Scalars['String']>;\n  _neq?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given case-insensitive pattern */\n  _nilike?: InputMaybe<Scalars['String']>;\n  _nin?: InputMaybe<Array<Scalars['String']>>;\n  /** does the column NOT match the given POSIX regular expression, case insensitive */\n  _niregex?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given pattern */\n  _nlike?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given POSIX regular expression, case sensitive */\n  _nregex?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given SQL regular expression */\n  _nsimilar?: InputMaybe<Scalars['String']>;\n  /** does the column match the given POSIX regular expression, case sensitive */\n  _regex?: InputMaybe<Scalars['String']>;\n  /** does the column match the given SQL regular expression */\n  _similar?: InputMaybe<Scalars['String']>;\n};\n\n/** Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'. */\nexport type Bigint_Comparison_Exp = {\n  _eq?: InputMaybe<Scalars['bigint']>;\n  _gt?: InputMaybe<Scalars['bigint']>;\n  _gte?: InputMaybe<Scalars['bigint']>;\n  _in?: InputMaybe<Array<Scalars['bigint']>>;\n  _is_null?: InputMaybe<Scalars['Boolean']>;\n  _lt?: InputMaybe<Scalars['bigint']>;\n  _lte?: InputMaybe<Scalars['bigint']>;\n  _neq?: InputMaybe<Scalars['bigint']>;\n  _nin?: InputMaybe<Array<Scalars['bigint']>>;\n};\n\n/** ordering argument of a cursor */\nexport type Cursor_Ordering =\n  /** ascending ordering of the cursor */\n  | 'ASC'\n  /** descending ordering of the cursor */\n  | 'DESC';\n\n/** columns and relationships of \"customers\" */\nexport type Customers = {\n  __typename?: 'customers';\n  customer_id: Scalars['String'];\n  email_address?: Maybe<Scalars['String']>;\n  first_name?: Maybe<Scalars['String']>;\n  last_name?: Maybe<Scalars['String']>;\n  /** An array relationship */\n  sale_transactions: Array<Sale_Transactions>;\n  /** An aggregate relationship */\n  sale_transactions_aggregate: Sale_Transactions_Aggregate;\n};\n\n\n/** columns and relationships of \"customers\" */\nexport type CustomersSale_TransactionsArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n\n/** columns and relationships of \"customers\" */\nexport type CustomersSale_Transactions_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n/** aggregated selection of \"customers\" */\nexport type Customers_Aggregate = {\n  __typename?: 'customers_aggregate';\n  aggregate?: Maybe<Customers_Aggregate_Fields>;\n  nodes: Array<Customers>;\n};\n\n/** aggregate fields of \"customers\" */\nexport type Customers_Aggregate_Fields = {\n  __typename?: 'customers_aggregate_fields';\n  count: Scalars['Int'];\n  max?: Maybe<Customers_Max_Fields>;\n  min?: Maybe<Customers_Min_Fields>;\n};\n\n\n/** aggregate fields of \"customers\" */\nexport type Customers_Aggregate_FieldsCountArgs = {\n  columns?: InputMaybe<Array<Customers_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Boolean expression to filter rows from the table \"customers\". All fields are combined with a logical 'AND'. */\nexport type Customers_Bool_Exp = {\n  _and?: InputMaybe<Array<Customers_Bool_Exp>>;\n  _not?: InputMaybe<Customers_Bool_Exp>;\n  _or?: InputMaybe<Array<Customers_Bool_Exp>>;\n  customer_id?: InputMaybe<String_Comparison_Exp>;\n  email_address?: InputMaybe<String_Comparison_Exp>;\n  first_name?: InputMaybe<String_Comparison_Exp>;\n  last_name?: InputMaybe<String_Comparison_Exp>;\n  sale_transactions?: InputMaybe<Sale_Transactions_Bool_Exp>;\n  sale_transactions_aggregate?: InputMaybe<Sale_Transactions_Aggregate_Bool_Exp>;\n};\n\n/** unique or primary key constraints on table \"customers\" */\nexport type Customers_Constraint =\n  /** unique or primary key constraint on columns \"customer_id\" */\n  | 'customers_pkey';\n\n/** input type for inserting data into table \"customers\" */\nexport type Customers_Insert_Input = {\n  customer_id?: InputMaybe<Scalars['String']>;\n  email_address?: InputMaybe<Scalars['String']>;\n  first_name?: InputMaybe<Scalars['String']>;\n  last_name?: InputMaybe<Scalars['String']>;\n  sale_transactions?: InputMaybe<Sale_Transactions_Arr_Rel_Insert_Input>;\n};\n\n/** aggregate max on columns */\nexport type Customers_Max_Fields = {\n  __typename?: 'customers_max_fields';\n  customer_id?: Maybe<Scalars['String']>;\n  email_address?: Maybe<Scalars['String']>;\n  first_name?: Maybe<Scalars['String']>;\n  last_name?: Maybe<Scalars['String']>;\n};\n\n/** aggregate min on columns */\nexport type Customers_Min_Fields = {\n  __typename?: 'customers_min_fields';\n  customer_id?: Maybe<Scalars['String']>;\n  email_address?: Maybe<Scalars['String']>;\n  first_name?: Maybe<Scalars['String']>;\n  last_name?: Maybe<Scalars['String']>;\n};\n\n/** response of any mutation on the table \"customers\" */\nexport type Customers_Mutation_Response = {\n  __typename?: 'customers_mutation_response';\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars['Int'];\n  /** data from the rows affected by the mutation */\n  returning: Array<Customers>;\n};\n\n/** input type for inserting object relation for remote table \"customers\" */\nexport type Customers_Obj_Rel_Insert_Input = {\n  data: Customers_Insert_Input;\n  /** upsert condition */\n  on_conflict?: InputMaybe<Customers_On_Conflict>;\n};\n\n/** on_conflict condition type for table \"customers\" */\nexport type Customers_On_Conflict = {\n  constraint: Customers_Constraint;\n  update_columns?: Array<Customers_Update_Column>;\n  where?: InputMaybe<Customers_Bool_Exp>;\n};\n\n/** Ordering options when selecting data from \"customers\". */\nexport type Customers_Order_By = {\n  customer_id?: InputMaybe<Order_By>;\n  email_address?: InputMaybe<Order_By>;\n  first_name?: InputMaybe<Order_By>;\n  last_name?: InputMaybe<Order_By>;\n  sale_transactions_aggregate?: InputMaybe<Sale_Transactions_Aggregate_Order_By>;\n};\n\n/** primary key columns input for table: customers */\nexport type Customers_Pk_Columns_Input = {\n  customer_id: Scalars['String'];\n};\n\n/** select columns of table \"customers\" */\nexport type Customers_Select_Column =\n  /** column name */\n  | 'customer_id'\n  /** column name */\n  | 'email_address'\n  /** column name */\n  | 'first_name'\n  /** column name */\n  | 'last_name';\n\n/** input type for updating data in table \"customers\" */\nexport type Customers_Set_Input = {\n  customer_id?: InputMaybe<Scalars['String']>;\n  email_address?: InputMaybe<Scalars['String']>;\n  first_name?: InputMaybe<Scalars['String']>;\n  last_name?: InputMaybe<Scalars['String']>;\n};\n\n/** Streaming cursor of the table \"customers\" */\nexport type Customers_Stream_Cursor_Input = {\n  /** Stream column input with initial value */\n  initial_value: Customers_Stream_Cursor_Value_Input;\n  /** cursor ordering */\n  ordering?: InputMaybe<Cursor_Ordering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type Customers_Stream_Cursor_Value_Input = {\n  customer_id?: InputMaybe<Scalars['String']>;\n  email_address?: InputMaybe<Scalars['String']>;\n  first_name?: InputMaybe<Scalars['String']>;\n  last_name?: InputMaybe<Scalars['String']>;\n};\n\n/** update columns of table \"customers\" */\nexport type Customers_Update_Column =\n  /** column name */\n  | 'customer_id'\n  /** column name */\n  | 'email_address'\n  /** column name */\n  | 'first_name'\n  /** column name */\n  | 'last_name';\n\nexport type Customers_Updates = {\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<Customers_Set_Input>;\n  /** filter the rows which have to be updated */\n  where: Customers_Bool_Exp;\n};\n\n/** Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'. */\nexport type Date_Comparison_Exp = {\n  _eq?: InputMaybe<Scalars['date']>;\n  _gt?: InputMaybe<Scalars['date']>;\n  _gte?: InputMaybe<Scalars['date']>;\n  _in?: InputMaybe<Array<Scalars['date']>>;\n  _is_null?: InputMaybe<Scalars['Boolean']>;\n  _lt?: InputMaybe<Scalars['date']>;\n  _lte?: InputMaybe<Scalars['date']>;\n  _neq?: InputMaybe<Scalars['date']>;\n  _nin?: InputMaybe<Array<Scalars['date']>>;\n};\n\n/** columns and relationships of \"employees\" */\nexport type Employees = {\n  __typename?: 'employees';\n  employee_id: Scalars['String'];\n  /** An array relationship */\n  sale_transactions: Array<Sale_Transactions>;\n  /** An aggregate relationship */\n  sale_transactions_aggregate: Sale_Transactions_Aggregate;\n  start_date?: Maybe<Scalars['date']>;\n};\n\n\n/** columns and relationships of \"employees\" */\nexport type EmployeesSale_TransactionsArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n\n/** columns and relationships of \"employees\" */\nexport type EmployeesSale_Transactions_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n/** aggregated selection of \"employees\" */\nexport type Employees_Aggregate = {\n  __typename?: 'employees_aggregate';\n  aggregate?: Maybe<Employees_Aggregate_Fields>;\n  nodes: Array<Employees>;\n};\n\n/** aggregate fields of \"employees\" */\nexport type Employees_Aggregate_Fields = {\n  __typename?: 'employees_aggregate_fields';\n  count: Scalars['Int'];\n  max?: Maybe<Employees_Max_Fields>;\n  min?: Maybe<Employees_Min_Fields>;\n};\n\n\n/** aggregate fields of \"employees\" */\nexport type Employees_Aggregate_FieldsCountArgs = {\n  columns?: InputMaybe<Array<Employees_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Boolean expression to filter rows from the table \"employees\". All fields are combined with a logical 'AND'. */\nexport type Employees_Bool_Exp = {\n  _and?: InputMaybe<Array<Employees_Bool_Exp>>;\n  _not?: InputMaybe<Employees_Bool_Exp>;\n  _or?: InputMaybe<Array<Employees_Bool_Exp>>;\n  employee_id?: InputMaybe<String_Comparison_Exp>;\n  sale_transactions?: InputMaybe<Sale_Transactions_Bool_Exp>;\n  sale_transactions_aggregate?: InputMaybe<Sale_Transactions_Aggregate_Bool_Exp>;\n  start_date?: InputMaybe<Date_Comparison_Exp>;\n};\n\n/** unique or primary key constraints on table \"employees\" */\nexport type Employees_Constraint =\n  /** unique or primary key constraint on columns \"employee_id\" */\n  | 'employees_pkey';\n\n/** input type for inserting data into table \"employees\" */\nexport type Employees_Insert_Input = {\n  employee_id?: InputMaybe<Scalars['String']>;\n  sale_transactions?: InputMaybe<Sale_Transactions_Arr_Rel_Insert_Input>;\n  start_date?: InputMaybe<Scalars['date']>;\n};\n\n/** aggregate max on columns */\nexport type Employees_Max_Fields = {\n  __typename?: 'employees_max_fields';\n  employee_id?: Maybe<Scalars['String']>;\n  start_date?: Maybe<Scalars['date']>;\n};\n\n/** aggregate min on columns */\nexport type Employees_Min_Fields = {\n  __typename?: 'employees_min_fields';\n  employee_id?: Maybe<Scalars['String']>;\n  start_date?: Maybe<Scalars['date']>;\n};\n\n/** response of any mutation on the table \"employees\" */\nexport type Employees_Mutation_Response = {\n  __typename?: 'employees_mutation_response';\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars['Int'];\n  /** data from the rows affected by the mutation */\n  returning: Array<Employees>;\n};\n\n/** input type for inserting object relation for remote table \"employees\" */\nexport type Employees_Obj_Rel_Insert_Input = {\n  data: Employees_Insert_Input;\n  /** upsert condition */\n  on_conflict?: InputMaybe<Employees_On_Conflict>;\n};\n\n/** on_conflict condition type for table \"employees\" */\nexport type Employees_On_Conflict = {\n  constraint: Employees_Constraint;\n  update_columns?: Array<Employees_Update_Column>;\n  where?: InputMaybe<Employees_Bool_Exp>;\n};\n\n/** Ordering options when selecting data from \"employees\". */\nexport type Employees_Order_By = {\n  employee_id?: InputMaybe<Order_By>;\n  sale_transactions_aggregate?: InputMaybe<Sale_Transactions_Aggregate_Order_By>;\n  start_date?: InputMaybe<Order_By>;\n};\n\n/** primary key columns input for table: employees */\nexport type Employees_Pk_Columns_Input = {\n  employee_id: Scalars['String'];\n};\n\n/** select columns of table \"employees\" */\nexport type Employees_Select_Column =\n  /** column name */\n  | 'employee_id'\n  /** column name */\n  | 'start_date';\n\n/** input type for updating data in table \"employees\" */\nexport type Employees_Set_Input = {\n  employee_id?: InputMaybe<Scalars['String']>;\n  start_date?: InputMaybe<Scalars['date']>;\n};\n\n/** Streaming cursor of the table \"employees\" */\nexport type Employees_Stream_Cursor_Input = {\n  /** Stream column input with initial value */\n  initial_value: Employees_Stream_Cursor_Value_Input;\n  /** cursor ordering */\n  ordering?: InputMaybe<Cursor_Ordering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type Employees_Stream_Cursor_Value_Input = {\n  employee_id?: InputMaybe<Scalars['String']>;\n  start_date?: InputMaybe<Scalars['date']>;\n};\n\n/** update columns of table \"employees\" */\nexport type Employees_Update_Column =\n  /** column name */\n  | 'employee_id'\n  /** column name */\n  | 'start_date';\n\nexport type Employees_Updates = {\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<Employees_Set_Input>;\n  /** filter the rows which have to be updated */\n  where: Employees_Bool_Exp;\n};\n\n/** columns and relationships of \"inventory\" */\nexport type Inventory = {\n  __typename?: 'inventory';\n  brand?: Maybe<Scalars['String']>;\n  category?: Maybe<Scalars['String']>;\n  item_id: Scalars['String'];\n  model?: Maybe<Scalars['String']>;\n  msrp?: Maybe<Scalars['numeric']>;\n  quantity?: Maybe<Scalars['Int']>;\n  sku?: Maybe<Scalars['String']>;\n  /** An array relationship */\n  sold_items: Array<Sold_Items>;\n  /** An aggregate relationship */\n  sold_items_aggregate: Sold_Items_Aggregate;\n  supplier?: Maybe<Scalars['String']>;\n  unit_price?: Maybe<Scalars['numeric']>;\n  upc?: Maybe<Scalars['String']>;\n};\n\n\n/** columns and relationships of \"inventory\" */\nexport type InventorySold_ItemsArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n\n/** columns and relationships of \"inventory\" */\nexport type InventorySold_Items_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n/** aggregated selection of \"inventory\" */\nexport type Inventory_Aggregate = {\n  __typename?: 'inventory_aggregate';\n  aggregate?: Maybe<Inventory_Aggregate_Fields>;\n  nodes: Array<Inventory>;\n};\n\n/** aggregate fields of \"inventory\" */\nexport type Inventory_Aggregate_Fields = {\n  __typename?: 'inventory_aggregate_fields';\n  avg?: Maybe<Inventory_Avg_Fields>;\n  count: Scalars['Int'];\n  max?: Maybe<Inventory_Max_Fields>;\n  min?: Maybe<Inventory_Min_Fields>;\n  stddev?: Maybe<Inventory_Stddev_Fields>;\n  stddev_pop?: Maybe<Inventory_Stddev_Pop_Fields>;\n  stddev_samp?: Maybe<Inventory_Stddev_Samp_Fields>;\n  sum?: Maybe<Inventory_Sum_Fields>;\n  var_pop?: Maybe<Inventory_Var_Pop_Fields>;\n  var_samp?: Maybe<Inventory_Var_Samp_Fields>;\n  variance?: Maybe<Inventory_Variance_Fields>;\n};\n\n\n/** aggregate fields of \"inventory\" */\nexport type Inventory_Aggregate_FieldsCountArgs = {\n  columns?: InputMaybe<Array<Inventory_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** aggregate avg on columns */\nexport type Inventory_Avg_Fields = {\n  __typename?: 'inventory_avg_fields';\n  msrp?: Maybe<Scalars['Float']>;\n  quantity?: Maybe<Scalars['Float']>;\n  unit_price?: Maybe<Scalars['Float']>;\n};\n\n/** Boolean expression to filter rows from the table \"inventory\". All fields are combined with a logical 'AND'. */\nexport type Inventory_Bool_Exp = {\n  _and?: InputMaybe<Array<Inventory_Bool_Exp>>;\n  _not?: InputMaybe<Inventory_Bool_Exp>;\n  _or?: InputMaybe<Array<Inventory_Bool_Exp>>;\n  brand?: InputMaybe<String_Comparison_Exp>;\n  category?: InputMaybe<String_Comparison_Exp>;\n  item_id?: InputMaybe<String_Comparison_Exp>;\n  model?: InputMaybe<String_Comparison_Exp>;\n  msrp?: InputMaybe<Numeric_Comparison_Exp>;\n  quantity?: InputMaybe<Int_Comparison_Exp>;\n  sku?: InputMaybe<String_Comparison_Exp>;\n  sold_items?: InputMaybe<Sold_Items_Bool_Exp>;\n  sold_items_aggregate?: InputMaybe<Sold_Items_Aggregate_Bool_Exp>;\n  supplier?: InputMaybe<String_Comparison_Exp>;\n  unit_price?: InputMaybe<Numeric_Comparison_Exp>;\n  upc?: InputMaybe<String_Comparison_Exp>;\n};\n\n/** unique or primary key constraints on table \"inventory\" */\nexport type Inventory_Constraint =\n  /** unique or primary key constraint on columns \"item_id\" */\n  | 'inventory_pkey';\n\n/** input type for incrementing numeric columns in table \"inventory\" */\nexport type Inventory_Inc_Input = {\n  msrp?: InputMaybe<Scalars['numeric']>;\n  quantity?: InputMaybe<Scalars['Int']>;\n  unit_price?: InputMaybe<Scalars['numeric']>;\n};\n\n/** input type for inserting data into table \"inventory\" */\nexport type Inventory_Insert_Input = {\n  brand?: InputMaybe<Scalars['String']>;\n  category?: InputMaybe<Scalars['String']>;\n  item_id?: InputMaybe<Scalars['String']>;\n  model?: InputMaybe<Scalars['String']>;\n  msrp?: InputMaybe<Scalars['numeric']>;\n  quantity?: InputMaybe<Scalars['Int']>;\n  sku?: InputMaybe<Scalars['String']>;\n  sold_items?: InputMaybe<Sold_Items_Arr_Rel_Insert_Input>;\n  supplier?: InputMaybe<Scalars['String']>;\n  unit_price?: InputMaybe<Scalars['numeric']>;\n  upc?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate max on columns */\nexport type Inventory_Max_Fields = {\n  __typename?: 'inventory_max_fields';\n  brand?: Maybe<Scalars['String']>;\n  category?: Maybe<Scalars['String']>;\n  item_id?: Maybe<Scalars['String']>;\n  model?: Maybe<Scalars['String']>;\n  msrp?: Maybe<Scalars['numeric']>;\n  quantity?: Maybe<Scalars['Int']>;\n  sku?: Maybe<Scalars['String']>;\n  supplier?: Maybe<Scalars['String']>;\n  unit_price?: Maybe<Scalars['numeric']>;\n  upc?: Maybe<Scalars['String']>;\n};\n\n/** aggregate min on columns */\nexport type Inventory_Min_Fields = {\n  __typename?: 'inventory_min_fields';\n  brand?: Maybe<Scalars['String']>;\n  category?: Maybe<Scalars['String']>;\n  item_id?: Maybe<Scalars['String']>;\n  model?: Maybe<Scalars['String']>;\n  msrp?: Maybe<Scalars['numeric']>;\n  quantity?: Maybe<Scalars['Int']>;\n  sku?: Maybe<Scalars['String']>;\n  supplier?: Maybe<Scalars['String']>;\n  unit_price?: Maybe<Scalars['numeric']>;\n  upc?: Maybe<Scalars['String']>;\n};\n\n/** response of any mutation on the table \"inventory\" */\nexport type Inventory_Mutation_Response = {\n  __typename?: 'inventory_mutation_response';\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars['Int'];\n  /** data from the rows affected by the mutation */\n  returning: Array<Inventory>;\n};\n\n/** input type for inserting object relation for remote table \"inventory\" */\nexport type Inventory_Obj_Rel_Insert_Input = {\n  data: Inventory_Insert_Input;\n  /** upsert condition */\n  on_conflict?: InputMaybe<Inventory_On_Conflict>;\n};\n\n/** on_conflict condition type for table \"inventory\" */\nexport type Inventory_On_Conflict = {\n  constraint: Inventory_Constraint;\n  update_columns?: Array<Inventory_Update_Column>;\n  where?: InputMaybe<Inventory_Bool_Exp>;\n};\n\n/** Ordering options when selecting data from \"inventory\". */\nexport type Inventory_Order_By = {\n  brand?: InputMaybe<Order_By>;\n  category?: InputMaybe<Order_By>;\n  item_id?: InputMaybe<Order_By>;\n  model?: InputMaybe<Order_By>;\n  msrp?: InputMaybe<Order_By>;\n  quantity?: InputMaybe<Order_By>;\n  sku?: InputMaybe<Order_By>;\n  sold_items_aggregate?: InputMaybe<Sold_Items_Aggregate_Order_By>;\n  supplier?: InputMaybe<Order_By>;\n  unit_price?: InputMaybe<Order_By>;\n  upc?: InputMaybe<Order_By>;\n};\n\n/** primary key columns input for table: inventory */\nexport type Inventory_Pk_Columns_Input = {\n  item_id: Scalars['String'];\n};\n\n/** select columns of table \"inventory\" */\nexport type Inventory_Select_Column =\n  /** column name */\n  | 'brand'\n  /** column name */\n  | 'category'\n  /** column name */\n  | 'item_id'\n  /** column name */\n  | 'model'\n  /** column name */\n  | 'msrp'\n  /** column name */\n  | 'quantity'\n  /** column name */\n  | 'sku'\n  /** column name */\n  | 'supplier'\n  /** column name */\n  | 'unit_price'\n  /** column name */\n  | 'upc';\n\n/** input type for updating data in table \"inventory\" */\nexport type Inventory_Set_Input = {\n  brand?: InputMaybe<Scalars['String']>;\n  category?: InputMaybe<Scalars['String']>;\n  item_id?: InputMaybe<Scalars['String']>;\n  model?: InputMaybe<Scalars['String']>;\n  msrp?: InputMaybe<Scalars['numeric']>;\n  quantity?: InputMaybe<Scalars['Int']>;\n  sku?: InputMaybe<Scalars['String']>;\n  supplier?: InputMaybe<Scalars['String']>;\n  unit_price?: InputMaybe<Scalars['numeric']>;\n  upc?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate stddev on columns */\nexport type Inventory_Stddev_Fields = {\n  __typename?: 'inventory_stddev_fields';\n  msrp?: Maybe<Scalars['Float']>;\n  quantity?: Maybe<Scalars['Float']>;\n  unit_price?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type Inventory_Stddev_Pop_Fields = {\n  __typename?: 'inventory_stddev_pop_fields';\n  msrp?: Maybe<Scalars['Float']>;\n  quantity?: Maybe<Scalars['Float']>;\n  unit_price?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type Inventory_Stddev_Samp_Fields = {\n  __typename?: 'inventory_stddev_samp_fields';\n  msrp?: Maybe<Scalars['Float']>;\n  quantity?: Maybe<Scalars['Float']>;\n  unit_price?: Maybe<Scalars['Float']>;\n};\n\n/** Streaming cursor of the table \"inventory\" */\nexport type Inventory_Stream_Cursor_Input = {\n  /** Stream column input with initial value */\n  initial_value: Inventory_Stream_Cursor_Value_Input;\n  /** cursor ordering */\n  ordering?: InputMaybe<Cursor_Ordering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type Inventory_Stream_Cursor_Value_Input = {\n  brand?: InputMaybe<Scalars['String']>;\n  category?: InputMaybe<Scalars['String']>;\n  item_id?: InputMaybe<Scalars['String']>;\n  model?: InputMaybe<Scalars['String']>;\n  msrp?: InputMaybe<Scalars['numeric']>;\n  quantity?: InputMaybe<Scalars['Int']>;\n  sku?: InputMaybe<Scalars['String']>;\n  supplier?: InputMaybe<Scalars['String']>;\n  unit_price?: InputMaybe<Scalars['numeric']>;\n  upc?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate sum on columns */\nexport type Inventory_Sum_Fields = {\n  __typename?: 'inventory_sum_fields';\n  msrp?: Maybe<Scalars['numeric']>;\n  quantity?: Maybe<Scalars['Int']>;\n  unit_price?: Maybe<Scalars['numeric']>;\n};\n\n/** update columns of table \"inventory\" */\nexport type Inventory_Update_Column =\n  /** column name */\n  | 'brand'\n  /** column name */\n  | 'category'\n  /** column name */\n  | 'item_id'\n  /** column name */\n  | 'model'\n  /** column name */\n  | 'msrp'\n  /** column name */\n  | 'quantity'\n  /** column name */\n  | 'sku'\n  /** column name */\n  | 'supplier'\n  /** column name */\n  | 'unit_price'\n  /** column name */\n  | 'upc';\n\nexport type Inventory_Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<Inventory_Inc_Input>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<Inventory_Set_Input>;\n  /** filter the rows which have to be updated */\n  where: Inventory_Bool_Exp;\n};\n\n/** aggregate var_pop on columns */\nexport type Inventory_Var_Pop_Fields = {\n  __typename?: 'inventory_var_pop_fields';\n  msrp?: Maybe<Scalars['Float']>;\n  quantity?: Maybe<Scalars['Float']>;\n  unit_price?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate var_samp on columns */\nexport type Inventory_Var_Samp_Fields = {\n  __typename?: 'inventory_var_samp_fields';\n  msrp?: Maybe<Scalars['Float']>;\n  quantity?: Maybe<Scalars['Float']>;\n  unit_price?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate variance on columns */\nexport type Inventory_Variance_Fields = {\n  __typename?: 'inventory_variance_fields';\n  msrp?: Maybe<Scalars['Float']>;\n  quantity?: Maybe<Scalars['Float']>;\n  unit_price?: Maybe<Scalars['Float']>;\n};\n\n/** mutation root */\nexport type Mutation_Root = {\n  __typename?: 'mutation_root';\n  /** delete data from the table: \"customers\" */\n  delete_customers?: Maybe<Customers_Mutation_Response>;\n  /** delete single row from the table: \"customers\" */\n  delete_customers_by_pk?: Maybe<Customers>;\n  /** delete data from the table: \"employees\" */\n  delete_employees?: Maybe<Employees_Mutation_Response>;\n  /** delete single row from the table: \"employees\" */\n  delete_employees_by_pk?: Maybe<Employees>;\n  /** delete data from the table: \"inventory\" */\n  delete_inventory?: Maybe<Inventory_Mutation_Response>;\n  /** delete single row from the table: \"inventory\" */\n  delete_inventory_by_pk?: Maybe<Inventory>;\n  /** delete data from the table: \"sale_transactions\" */\n  delete_sale_transactions?: Maybe<Sale_Transactions_Mutation_Response>;\n  /** delete single row from the table: \"sale_transactions\" */\n  delete_sale_transactions_by_pk?: Maybe<Sale_Transactions>;\n  /** delete data from the table: \"sold_items\" */\n  delete_sold_items?: Maybe<Sold_Items_Mutation_Response>;\n  /** delete single row from the table: \"sold_items\" */\n  delete_sold_items_by_pk?: Maybe<Sold_Items>;\n  /** insert data into the table: \"customers\" */\n  insert_customers?: Maybe<Customers_Mutation_Response>;\n  /** insert a single row into the table: \"customers\" */\n  insert_customers_one?: Maybe<Customers>;\n  /** insert data into the table: \"employees\" */\n  insert_employees?: Maybe<Employees_Mutation_Response>;\n  /** insert a single row into the table: \"employees\" */\n  insert_employees_one?: Maybe<Employees>;\n  /** insert data into the table: \"inventory\" */\n  insert_inventory?: Maybe<Inventory_Mutation_Response>;\n  /** insert a single row into the table: \"inventory\" */\n  insert_inventory_one?: Maybe<Inventory>;\n  /** insert data into the table: \"sale_transactions\" */\n  insert_sale_transactions?: Maybe<Sale_Transactions_Mutation_Response>;\n  /** insert a single row into the table: \"sale_transactions\" */\n  insert_sale_transactions_one?: Maybe<Sale_Transactions>;\n  /** insert data into the table: \"sold_items\" */\n  insert_sold_items?: Maybe<Sold_Items_Mutation_Response>;\n  /** insert a single row into the table: \"sold_items\" */\n  insert_sold_items_one?: Maybe<Sold_Items>;\n  /** update data of the table: \"customers\" */\n  update_customers?: Maybe<Customers_Mutation_Response>;\n  /** update single row of the table: \"customers\" */\n  update_customers_by_pk?: Maybe<Customers>;\n  /** update multiples rows of table: \"customers\" */\n  update_customers_many?: Maybe<Array<Maybe<Customers_Mutation_Response>>>;\n  /** update data of the table: \"employees\" */\n  update_employees?: Maybe<Employees_Mutation_Response>;\n  /** update single row of the table: \"employees\" */\n  update_employees_by_pk?: Maybe<Employees>;\n  /** update multiples rows of table: \"employees\" */\n  update_employees_many?: Maybe<Array<Maybe<Employees_Mutation_Response>>>;\n  /** update data of the table: \"inventory\" */\n  update_inventory?: Maybe<Inventory_Mutation_Response>;\n  /** update single row of the table: \"inventory\" */\n  update_inventory_by_pk?: Maybe<Inventory>;\n  /** update multiples rows of table: \"inventory\" */\n  update_inventory_many?: Maybe<Array<Maybe<Inventory_Mutation_Response>>>;\n  /** update data of the table: \"sale_transactions\" */\n  update_sale_transactions?: Maybe<Sale_Transactions_Mutation_Response>;\n  /** update single row of the table: \"sale_transactions\" */\n  update_sale_transactions_by_pk?: Maybe<Sale_Transactions>;\n  /** update multiples rows of table: \"sale_transactions\" */\n  update_sale_transactions_many?: Maybe<Array<Maybe<Sale_Transactions_Mutation_Response>>>;\n  /** update data of the table: \"sold_items\" */\n  update_sold_items?: Maybe<Sold_Items_Mutation_Response>;\n  /** update single row of the table: \"sold_items\" */\n  update_sold_items_by_pk?: Maybe<Sold_Items>;\n  /** update multiples rows of table: \"sold_items\" */\n  update_sold_items_many?: Maybe<Array<Maybe<Sold_Items_Mutation_Response>>>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_CustomersArgs = {\n  where: Customers_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Customers_By_PkArgs = {\n  customer_id: Scalars['String'];\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_EmployeesArgs = {\n  where: Employees_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Employees_By_PkArgs = {\n  employee_id: Scalars['String'];\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_InventoryArgs = {\n  where: Inventory_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Inventory_By_PkArgs = {\n  item_id: Scalars['String'];\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Sale_TransactionsArgs = {\n  where: Sale_Transactions_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Sale_Transactions_By_PkArgs = {\n  transaction_id: Scalars['String'];\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Sold_ItemsArgs = {\n  where: Sold_Items_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Sold_Items_By_PkArgs = {\n  sold_item_count: Scalars['bigint'];\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_CustomersArgs = {\n  objects: Array<Customers_Insert_Input>;\n  on_conflict?: InputMaybe<Customers_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Customers_OneArgs = {\n  object: Customers_Insert_Input;\n  on_conflict?: InputMaybe<Customers_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_EmployeesArgs = {\n  objects: Array<Employees_Insert_Input>;\n  on_conflict?: InputMaybe<Employees_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Employees_OneArgs = {\n  object: Employees_Insert_Input;\n  on_conflict?: InputMaybe<Employees_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_InventoryArgs = {\n  objects: Array<Inventory_Insert_Input>;\n  on_conflict?: InputMaybe<Inventory_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Inventory_OneArgs = {\n  object: Inventory_Insert_Input;\n  on_conflict?: InputMaybe<Inventory_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Sale_TransactionsArgs = {\n  objects: Array<Sale_Transactions_Insert_Input>;\n  on_conflict?: InputMaybe<Sale_Transactions_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Sale_Transactions_OneArgs = {\n  object: Sale_Transactions_Insert_Input;\n  on_conflict?: InputMaybe<Sale_Transactions_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Sold_ItemsArgs = {\n  objects: Array<Sold_Items_Insert_Input>;\n  on_conflict?: InputMaybe<Sold_Items_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Sold_Items_OneArgs = {\n  object: Sold_Items_Insert_Input;\n  on_conflict?: InputMaybe<Sold_Items_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_CustomersArgs = {\n  _set?: InputMaybe<Customers_Set_Input>;\n  where: Customers_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Customers_By_PkArgs = {\n  _set?: InputMaybe<Customers_Set_Input>;\n  pk_columns: Customers_Pk_Columns_Input;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Customers_ManyArgs = {\n  updates: Array<Customers_Updates>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_EmployeesArgs = {\n  _set?: InputMaybe<Employees_Set_Input>;\n  where: Employees_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Employees_By_PkArgs = {\n  _set?: InputMaybe<Employees_Set_Input>;\n  pk_columns: Employees_Pk_Columns_Input;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Employees_ManyArgs = {\n  updates: Array<Employees_Updates>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_InventoryArgs = {\n  _inc?: InputMaybe<Inventory_Inc_Input>;\n  _set?: InputMaybe<Inventory_Set_Input>;\n  where: Inventory_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Inventory_By_PkArgs = {\n  _inc?: InputMaybe<Inventory_Inc_Input>;\n  _set?: InputMaybe<Inventory_Set_Input>;\n  pk_columns: Inventory_Pk_Columns_Input;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Inventory_ManyArgs = {\n  updates: Array<Inventory_Updates>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Sale_TransactionsArgs = {\n  _inc?: InputMaybe<Sale_Transactions_Inc_Input>;\n  _set?: InputMaybe<Sale_Transactions_Set_Input>;\n  where: Sale_Transactions_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Sale_Transactions_By_PkArgs = {\n  _inc?: InputMaybe<Sale_Transactions_Inc_Input>;\n  _set?: InputMaybe<Sale_Transactions_Set_Input>;\n  pk_columns: Sale_Transactions_Pk_Columns_Input;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Sale_Transactions_ManyArgs = {\n  updates: Array<Sale_Transactions_Updates>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Sold_ItemsArgs = {\n  _inc?: InputMaybe<Sold_Items_Inc_Input>;\n  _set?: InputMaybe<Sold_Items_Set_Input>;\n  where: Sold_Items_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Sold_Items_By_PkArgs = {\n  _inc?: InputMaybe<Sold_Items_Inc_Input>;\n  _set?: InputMaybe<Sold_Items_Set_Input>;\n  pk_columns: Sold_Items_Pk_Columns_Input;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Sold_Items_ManyArgs = {\n  updates: Array<Sold_Items_Updates>;\n};\n\n/** Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'. */\nexport type Numeric_Comparison_Exp = {\n  _eq?: InputMaybe<Scalars['numeric']>;\n  _gt?: InputMaybe<Scalars['numeric']>;\n  _gte?: InputMaybe<Scalars['numeric']>;\n  _in?: InputMaybe<Array<Scalars['numeric']>>;\n  _is_null?: InputMaybe<Scalars['Boolean']>;\n  _lt?: InputMaybe<Scalars['numeric']>;\n  _lte?: InputMaybe<Scalars['numeric']>;\n  _neq?: InputMaybe<Scalars['numeric']>;\n  _nin?: InputMaybe<Array<Scalars['numeric']>>;\n};\n\n/** column ordering options */\nexport type Order_By =\n  /** in ascending order, nulls last */\n  | 'asc'\n  /** in ascending order, nulls first */\n  | 'asc_nulls_first'\n  /** in ascending order, nulls last */\n  | 'asc_nulls_last'\n  /** in descending order, nulls first */\n  | 'desc'\n  /** in descending order, nulls first */\n  | 'desc_nulls_first'\n  /** in descending order, nulls last */\n  | 'desc_nulls_last';\n\nexport type Query_Root = {\n  __typename?: 'query_root';\n  /** fetch data from the table: \"customers\" */\n  customers: Array<Customers>;\n  /** fetch aggregated fields from the table: \"customers\" */\n  customers_aggregate: Customers_Aggregate;\n  /** fetch data from the table: \"customers\" using primary key columns */\n  customers_by_pk?: Maybe<Customers>;\n  /** fetch data from the table: \"employees\" */\n  employees: Array<Employees>;\n  /** fetch aggregated fields from the table: \"employees\" */\n  employees_aggregate: Employees_Aggregate;\n  /** fetch data from the table: \"employees\" using primary key columns */\n  employees_by_pk?: Maybe<Employees>;\n  /** fetch data from the table: \"inventory\" */\n  inventory: Array<Inventory>;\n  /** fetch aggregated fields from the table: \"inventory\" */\n  inventory_aggregate: Inventory_Aggregate;\n  /** fetch data from the table: \"inventory\" using primary key columns */\n  inventory_by_pk?: Maybe<Inventory>;\n  /** An array relationship */\n  sale_transactions: Array<Sale_Transactions>;\n  /** An aggregate relationship */\n  sale_transactions_aggregate: Sale_Transactions_Aggregate;\n  /** fetch data from the table: \"sale_transactions\" using primary key columns */\n  sale_transactions_by_pk?: Maybe<Sale_Transactions>;\n  /** An array relationship */\n  sold_items: Array<Sold_Items>;\n  /** An aggregate relationship */\n  sold_items_aggregate: Sold_Items_Aggregate;\n  /** fetch data from the table: \"sold_items\" using primary key columns */\n  sold_items_by_pk?: Maybe<Sold_Items>;\n};\n\n\nexport type Query_RootCustomersArgs = {\n  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Customers_Order_By>>;\n  where?: InputMaybe<Customers_Bool_Exp>;\n};\n\n\nexport type Query_RootCustomers_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Customers_Order_By>>;\n  where?: InputMaybe<Customers_Bool_Exp>;\n};\n\n\nexport type Query_RootCustomers_By_PkArgs = {\n  customer_id: Scalars['String'];\n};\n\n\nexport type Query_RootEmployeesArgs = {\n  distinct_on?: InputMaybe<Array<Employees_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Employees_Order_By>>;\n  where?: InputMaybe<Employees_Bool_Exp>;\n};\n\n\nexport type Query_RootEmployees_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Employees_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Employees_Order_By>>;\n  where?: InputMaybe<Employees_Bool_Exp>;\n};\n\n\nexport type Query_RootEmployees_By_PkArgs = {\n  employee_id: Scalars['String'];\n};\n\n\nexport type Query_RootInventoryArgs = {\n  distinct_on?: InputMaybe<Array<Inventory_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Inventory_Order_By>>;\n  where?: InputMaybe<Inventory_Bool_Exp>;\n};\n\n\nexport type Query_RootInventory_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Inventory_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Inventory_Order_By>>;\n  where?: InputMaybe<Inventory_Bool_Exp>;\n};\n\n\nexport type Query_RootInventory_By_PkArgs = {\n  item_id: Scalars['String'];\n};\n\n\nexport type Query_RootSale_TransactionsArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n\nexport type Query_RootSale_Transactions_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n\nexport type Query_RootSale_Transactions_By_PkArgs = {\n  transaction_id: Scalars['String'];\n};\n\n\nexport type Query_RootSold_ItemsArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n\nexport type Query_RootSold_Items_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n\nexport type Query_RootSold_Items_By_PkArgs = {\n  sold_item_count: Scalars['bigint'];\n};\n\n/** columns and relationships of \"sale_transactions\" */\nexport type Sale_Transactions = {\n  __typename?: 'sale_transactions';\n  /** An object relationship */\n  customer?: Maybe<Customers>;\n  customer_id?: Maybe<Scalars['String']>;\n  /** An object relationship */\n  employee?: Maybe<Employees>;\n  employee_id?: Maybe<Scalars['String']>;\n  item_count?: Maybe<Scalars['Int']>;\n  net_amount?: Maybe<Scalars['numeric']>;\n  profit?: Maybe<Scalars['numeric']>;\n  /** An array relationship */\n  sold_items: Array<Sold_Items>;\n  /** An aggregate relationship */\n  sold_items_aggregate: Sold_Items_Aggregate;\n  transaction_date?: Maybe<Scalars['date']>;\n  transaction_id: Scalars['String'];\n};\n\n\n/** columns and relationships of \"sale_transactions\" */\nexport type Sale_TransactionsSold_ItemsArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n\n/** columns and relationships of \"sale_transactions\" */\nexport type Sale_TransactionsSold_Items_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n/** aggregated selection of \"sale_transactions\" */\nexport type Sale_Transactions_Aggregate = {\n  __typename?: 'sale_transactions_aggregate';\n  aggregate?: Maybe<Sale_Transactions_Aggregate_Fields>;\n  nodes: Array<Sale_Transactions>;\n};\n\nexport type Sale_Transactions_Aggregate_Bool_Exp = {\n  count?: InputMaybe<Sale_Transactions_Aggregate_Bool_Exp_Count>;\n};\n\nexport type Sale_Transactions_Aggregate_Bool_Exp_Count = {\n  arguments?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n  filter?: InputMaybe<Sale_Transactions_Bool_Exp>;\n  predicate: Int_Comparison_Exp;\n};\n\n/** aggregate fields of \"sale_transactions\" */\nexport type Sale_Transactions_Aggregate_Fields = {\n  __typename?: 'sale_transactions_aggregate_fields';\n  avg?: Maybe<Sale_Transactions_Avg_Fields>;\n  count: Scalars['Int'];\n  max?: Maybe<Sale_Transactions_Max_Fields>;\n  min?: Maybe<Sale_Transactions_Min_Fields>;\n  stddev?: Maybe<Sale_Transactions_Stddev_Fields>;\n  stddev_pop?: Maybe<Sale_Transactions_Stddev_Pop_Fields>;\n  stddev_samp?: Maybe<Sale_Transactions_Stddev_Samp_Fields>;\n  sum?: Maybe<Sale_Transactions_Sum_Fields>;\n  var_pop?: Maybe<Sale_Transactions_Var_Pop_Fields>;\n  var_samp?: Maybe<Sale_Transactions_Var_Samp_Fields>;\n  variance?: Maybe<Sale_Transactions_Variance_Fields>;\n};\n\n\n/** aggregate fields of \"sale_transactions\" */\nexport type Sale_Transactions_Aggregate_FieldsCountArgs = {\n  columns?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** order by aggregate values of table \"sale_transactions\" */\nexport type Sale_Transactions_Aggregate_Order_By = {\n  avg?: InputMaybe<Sale_Transactions_Avg_Order_By>;\n  count?: InputMaybe<Order_By>;\n  max?: InputMaybe<Sale_Transactions_Max_Order_By>;\n  min?: InputMaybe<Sale_Transactions_Min_Order_By>;\n  stddev?: InputMaybe<Sale_Transactions_Stddev_Order_By>;\n  stddev_pop?: InputMaybe<Sale_Transactions_Stddev_Pop_Order_By>;\n  stddev_samp?: InputMaybe<Sale_Transactions_Stddev_Samp_Order_By>;\n  sum?: InputMaybe<Sale_Transactions_Sum_Order_By>;\n  var_pop?: InputMaybe<Sale_Transactions_Var_Pop_Order_By>;\n  var_samp?: InputMaybe<Sale_Transactions_Var_Samp_Order_By>;\n  variance?: InputMaybe<Sale_Transactions_Variance_Order_By>;\n};\n\n/** input type for inserting array relation for remote table \"sale_transactions\" */\nexport type Sale_Transactions_Arr_Rel_Insert_Input = {\n  data: Array<Sale_Transactions_Insert_Input>;\n  /** upsert condition */\n  on_conflict?: InputMaybe<Sale_Transactions_On_Conflict>;\n};\n\n/** aggregate avg on columns */\nexport type Sale_Transactions_Avg_Fields = {\n  __typename?: 'sale_transactions_avg_fields';\n  item_count?: Maybe<Scalars['Float']>;\n  net_amount?: Maybe<Scalars['Float']>;\n  profit?: Maybe<Scalars['Float']>;\n};\n\n/** order by avg() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Avg_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** Boolean expression to filter rows from the table \"sale_transactions\". All fields are combined with a logical 'AND'. */\nexport type Sale_Transactions_Bool_Exp = {\n  _and?: InputMaybe<Array<Sale_Transactions_Bool_Exp>>;\n  _not?: InputMaybe<Sale_Transactions_Bool_Exp>;\n  _or?: InputMaybe<Array<Sale_Transactions_Bool_Exp>>;\n  customer?: InputMaybe<Customers_Bool_Exp>;\n  customer_id?: InputMaybe<String_Comparison_Exp>;\n  employee?: InputMaybe<Employees_Bool_Exp>;\n  employee_id?: InputMaybe<String_Comparison_Exp>;\n  item_count?: InputMaybe<Int_Comparison_Exp>;\n  net_amount?: InputMaybe<Numeric_Comparison_Exp>;\n  profit?: InputMaybe<Numeric_Comparison_Exp>;\n  sold_items?: InputMaybe<Sold_Items_Bool_Exp>;\n  sold_items_aggregate?: InputMaybe<Sold_Items_Aggregate_Bool_Exp>;\n  transaction_date?: InputMaybe<Date_Comparison_Exp>;\n  transaction_id?: InputMaybe<String_Comparison_Exp>;\n};\n\n/** unique or primary key constraints on table \"sale_transactions\" */\nexport type Sale_Transactions_Constraint =\n  /** unique or primary key constraint on columns \"transaction_id\" */\n  | 'sale_transactions_pkey';\n\n/** input type for incrementing numeric columns in table \"sale_transactions\" */\nexport type Sale_Transactions_Inc_Input = {\n  item_count?: InputMaybe<Scalars['Int']>;\n  net_amount?: InputMaybe<Scalars['numeric']>;\n  profit?: InputMaybe<Scalars['numeric']>;\n};\n\n/** input type for inserting data into table \"sale_transactions\" */\nexport type Sale_Transactions_Insert_Input = {\n  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;\n  customer_id?: InputMaybe<Scalars['String']>;\n  employee?: InputMaybe<Employees_Obj_Rel_Insert_Input>;\n  employee_id?: InputMaybe<Scalars['String']>;\n  item_count?: InputMaybe<Scalars['Int']>;\n  net_amount?: InputMaybe<Scalars['numeric']>;\n  profit?: InputMaybe<Scalars['numeric']>;\n  sold_items?: InputMaybe<Sold_Items_Arr_Rel_Insert_Input>;\n  transaction_date?: InputMaybe<Scalars['date']>;\n  transaction_id?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate max on columns */\nexport type Sale_Transactions_Max_Fields = {\n  __typename?: 'sale_transactions_max_fields';\n  customer_id?: Maybe<Scalars['String']>;\n  employee_id?: Maybe<Scalars['String']>;\n  item_count?: Maybe<Scalars['Int']>;\n  net_amount?: Maybe<Scalars['numeric']>;\n  profit?: Maybe<Scalars['numeric']>;\n  transaction_date?: Maybe<Scalars['date']>;\n  transaction_id?: Maybe<Scalars['String']>;\n};\n\n/** order by max() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Max_Order_By = {\n  customer_id?: InputMaybe<Order_By>;\n  employee_id?: InputMaybe<Order_By>;\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n  transaction_date?: InputMaybe<Order_By>;\n  transaction_id?: InputMaybe<Order_By>;\n};\n\n/** aggregate min on columns */\nexport type Sale_Transactions_Min_Fields = {\n  __typename?: 'sale_transactions_min_fields';\n  customer_id?: Maybe<Scalars['String']>;\n  employee_id?: Maybe<Scalars['String']>;\n  item_count?: Maybe<Scalars['Int']>;\n  net_amount?: Maybe<Scalars['numeric']>;\n  profit?: Maybe<Scalars['numeric']>;\n  transaction_date?: Maybe<Scalars['date']>;\n  transaction_id?: Maybe<Scalars['String']>;\n};\n\n/** order by min() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Min_Order_By = {\n  customer_id?: InputMaybe<Order_By>;\n  employee_id?: InputMaybe<Order_By>;\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n  transaction_date?: InputMaybe<Order_By>;\n  transaction_id?: InputMaybe<Order_By>;\n};\n\n/** response of any mutation on the table \"sale_transactions\" */\nexport type Sale_Transactions_Mutation_Response = {\n  __typename?: 'sale_transactions_mutation_response';\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars['Int'];\n  /** data from the rows affected by the mutation */\n  returning: Array<Sale_Transactions>;\n};\n\n/** input type for inserting object relation for remote table \"sale_transactions\" */\nexport type Sale_Transactions_Obj_Rel_Insert_Input = {\n  data: Sale_Transactions_Insert_Input;\n  /** upsert condition */\n  on_conflict?: InputMaybe<Sale_Transactions_On_Conflict>;\n};\n\n/** on_conflict condition type for table \"sale_transactions\" */\nexport type Sale_Transactions_On_Conflict = {\n  constraint: Sale_Transactions_Constraint;\n  update_columns?: Array<Sale_Transactions_Update_Column>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n/** Ordering options when selecting data from \"sale_transactions\". */\nexport type Sale_Transactions_Order_By = {\n  customer?: InputMaybe<Customers_Order_By>;\n  customer_id?: InputMaybe<Order_By>;\n  employee?: InputMaybe<Employees_Order_By>;\n  employee_id?: InputMaybe<Order_By>;\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n  sold_items_aggregate?: InputMaybe<Sold_Items_Aggregate_Order_By>;\n  transaction_date?: InputMaybe<Order_By>;\n  transaction_id?: InputMaybe<Order_By>;\n};\n\n/** primary key columns input for table: sale_transactions */\nexport type Sale_Transactions_Pk_Columns_Input = {\n  transaction_id: Scalars['String'];\n};\n\n/** select columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Select_Column =\n  /** column name */\n  | 'customer_id'\n  /** column name */\n  | 'employee_id'\n  /** column name */\n  | 'item_count'\n  /** column name */\n  | 'net_amount'\n  /** column name */\n  | 'profit'\n  /** column name */\n  | 'transaction_date'\n  /** column name */\n  | 'transaction_id';\n\n/** input type for updating data in table \"sale_transactions\" */\nexport type Sale_Transactions_Set_Input = {\n  customer_id?: InputMaybe<Scalars['String']>;\n  employee_id?: InputMaybe<Scalars['String']>;\n  item_count?: InputMaybe<Scalars['Int']>;\n  net_amount?: InputMaybe<Scalars['numeric']>;\n  profit?: InputMaybe<Scalars['numeric']>;\n  transaction_date?: InputMaybe<Scalars['date']>;\n  transaction_id?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate stddev on columns */\nexport type Sale_Transactions_Stddev_Fields = {\n  __typename?: 'sale_transactions_stddev_fields';\n  item_count?: Maybe<Scalars['Float']>;\n  net_amount?: Maybe<Scalars['Float']>;\n  profit?: Maybe<Scalars['Float']>;\n};\n\n/** order by stddev() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Stddev_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type Sale_Transactions_Stddev_Pop_Fields = {\n  __typename?: 'sale_transactions_stddev_pop_fields';\n  item_count?: Maybe<Scalars['Float']>;\n  net_amount?: Maybe<Scalars['Float']>;\n  profit?: Maybe<Scalars['Float']>;\n};\n\n/** order by stddev_pop() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Stddev_Pop_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type Sale_Transactions_Stddev_Samp_Fields = {\n  __typename?: 'sale_transactions_stddev_samp_fields';\n  item_count?: Maybe<Scalars['Float']>;\n  net_amount?: Maybe<Scalars['Float']>;\n  profit?: Maybe<Scalars['Float']>;\n};\n\n/** order by stddev_samp() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Stddev_Samp_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** Streaming cursor of the table \"sale_transactions\" */\nexport type Sale_Transactions_Stream_Cursor_Input = {\n  /** Stream column input with initial value */\n  initial_value: Sale_Transactions_Stream_Cursor_Value_Input;\n  /** cursor ordering */\n  ordering?: InputMaybe<Cursor_Ordering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type Sale_Transactions_Stream_Cursor_Value_Input = {\n  customer_id?: InputMaybe<Scalars['String']>;\n  employee_id?: InputMaybe<Scalars['String']>;\n  item_count?: InputMaybe<Scalars['Int']>;\n  net_amount?: InputMaybe<Scalars['numeric']>;\n  profit?: InputMaybe<Scalars['numeric']>;\n  transaction_date?: InputMaybe<Scalars['date']>;\n  transaction_id?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate sum on columns */\nexport type Sale_Transactions_Sum_Fields = {\n  __typename?: 'sale_transactions_sum_fields';\n  item_count?: Maybe<Scalars['Int']>;\n  net_amount?: Maybe<Scalars['numeric']>;\n  profit?: Maybe<Scalars['numeric']>;\n};\n\n/** order by sum() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Sum_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** update columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Update_Column =\n  /** column name */\n  | 'customer_id'\n  /** column name */\n  | 'employee_id'\n  /** column name */\n  | 'item_count'\n  /** column name */\n  | 'net_amount'\n  /** column name */\n  | 'profit'\n  /** column name */\n  | 'transaction_date'\n  /** column name */\n  | 'transaction_id';\n\nexport type Sale_Transactions_Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<Sale_Transactions_Inc_Input>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<Sale_Transactions_Set_Input>;\n  /** filter the rows which have to be updated */\n  where: Sale_Transactions_Bool_Exp;\n};\n\n/** aggregate var_pop on columns */\nexport type Sale_Transactions_Var_Pop_Fields = {\n  __typename?: 'sale_transactions_var_pop_fields';\n  item_count?: Maybe<Scalars['Float']>;\n  net_amount?: Maybe<Scalars['Float']>;\n  profit?: Maybe<Scalars['Float']>;\n};\n\n/** order by var_pop() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Var_Pop_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** aggregate var_samp on columns */\nexport type Sale_Transactions_Var_Samp_Fields = {\n  __typename?: 'sale_transactions_var_samp_fields';\n  item_count?: Maybe<Scalars['Float']>;\n  net_amount?: Maybe<Scalars['Float']>;\n  profit?: Maybe<Scalars['Float']>;\n};\n\n/** order by var_samp() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Var_Samp_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** aggregate variance on columns */\nexport type Sale_Transactions_Variance_Fields = {\n  __typename?: 'sale_transactions_variance_fields';\n  item_count?: Maybe<Scalars['Float']>;\n  net_amount?: Maybe<Scalars['Float']>;\n  profit?: Maybe<Scalars['Float']>;\n};\n\n/** order by variance() on columns of table \"sale_transactions\" */\nexport type Sale_Transactions_Variance_Order_By = {\n  item_count?: InputMaybe<Order_By>;\n  net_amount?: InputMaybe<Order_By>;\n  profit?: InputMaybe<Order_By>;\n};\n\n/** columns and relationships of \"sold_items\" */\nexport type Sold_Items = {\n  __typename?: 'sold_items';\n  /** An object relationship */\n  inventory?: Maybe<Inventory>;\n  item_id?: Maybe<Scalars['String']>;\n  /** An object relationship */\n  sale_transaction?: Maybe<Sale_Transactions>;\n  sold_item_count: Scalars['bigint'];\n  transaction_id?: Maybe<Scalars['String']>;\n};\n\n/** aggregated selection of \"sold_items\" */\nexport type Sold_Items_Aggregate = {\n  __typename?: 'sold_items_aggregate';\n  aggregate?: Maybe<Sold_Items_Aggregate_Fields>;\n  nodes: Array<Sold_Items>;\n};\n\nexport type Sold_Items_Aggregate_Bool_Exp = {\n  count?: InputMaybe<Sold_Items_Aggregate_Bool_Exp_Count>;\n};\n\nexport type Sold_Items_Aggregate_Bool_Exp_Count = {\n  arguments?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n  filter?: InputMaybe<Sold_Items_Bool_Exp>;\n  predicate: Int_Comparison_Exp;\n};\n\n/** aggregate fields of \"sold_items\" */\nexport type Sold_Items_Aggregate_Fields = {\n  __typename?: 'sold_items_aggregate_fields';\n  avg?: Maybe<Sold_Items_Avg_Fields>;\n  count: Scalars['Int'];\n  max?: Maybe<Sold_Items_Max_Fields>;\n  min?: Maybe<Sold_Items_Min_Fields>;\n  stddev?: Maybe<Sold_Items_Stddev_Fields>;\n  stddev_pop?: Maybe<Sold_Items_Stddev_Pop_Fields>;\n  stddev_samp?: Maybe<Sold_Items_Stddev_Samp_Fields>;\n  sum?: Maybe<Sold_Items_Sum_Fields>;\n  var_pop?: Maybe<Sold_Items_Var_Pop_Fields>;\n  var_samp?: Maybe<Sold_Items_Var_Samp_Fields>;\n  variance?: Maybe<Sold_Items_Variance_Fields>;\n};\n\n\n/** aggregate fields of \"sold_items\" */\nexport type Sold_Items_Aggregate_FieldsCountArgs = {\n  columns?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** order by aggregate values of table \"sold_items\" */\nexport type Sold_Items_Aggregate_Order_By = {\n  avg?: InputMaybe<Sold_Items_Avg_Order_By>;\n  count?: InputMaybe<Order_By>;\n  max?: InputMaybe<Sold_Items_Max_Order_By>;\n  min?: InputMaybe<Sold_Items_Min_Order_By>;\n  stddev?: InputMaybe<Sold_Items_Stddev_Order_By>;\n  stddev_pop?: InputMaybe<Sold_Items_Stddev_Pop_Order_By>;\n  stddev_samp?: InputMaybe<Sold_Items_Stddev_Samp_Order_By>;\n  sum?: InputMaybe<Sold_Items_Sum_Order_By>;\n  var_pop?: InputMaybe<Sold_Items_Var_Pop_Order_By>;\n  var_samp?: InputMaybe<Sold_Items_Var_Samp_Order_By>;\n  variance?: InputMaybe<Sold_Items_Variance_Order_By>;\n};\n\n/** input type for inserting array relation for remote table \"sold_items\" */\nexport type Sold_Items_Arr_Rel_Insert_Input = {\n  data: Array<Sold_Items_Insert_Input>;\n  /** upsert condition */\n  on_conflict?: InputMaybe<Sold_Items_On_Conflict>;\n};\n\n/** aggregate avg on columns */\nexport type Sold_Items_Avg_Fields = {\n  __typename?: 'sold_items_avg_fields';\n  sold_item_count?: Maybe<Scalars['Float']>;\n};\n\n/** order by avg() on columns of table \"sold_items\" */\nexport type Sold_Items_Avg_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\n/** Boolean expression to filter rows from the table \"sold_items\". All fields are combined with a logical 'AND'. */\nexport type Sold_Items_Bool_Exp = {\n  _and?: InputMaybe<Array<Sold_Items_Bool_Exp>>;\n  _not?: InputMaybe<Sold_Items_Bool_Exp>;\n  _or?: InputMaybe<Array<Sold_Items_Bool_Exp>>;\n  inventory?: InputMaybe<Inventory_Bool_Exp>;\n  item_id?: InputMaybe<String_Comparison_Exp>;\n  sale_transaction?: InputMaybe<Sale_Transactions_Bool_Exp>;\n  sold_item_count?: InputMaybe<Bigint_Comparison_Exp>;\n  transaction_id?: InputMaybe<String_Comparison_Exp>;\n};\n\n/** unique or primary key constraints on table \"sold_items\" */\nexport type Sold_Items_Constraint =\n  /** unique or primary key constraint on columns \"sold_item_count\" */\n  | 'sold_items_pkey';\n\n/** input type for incrementing numeric columns in table \"sold_items\" */\nexport type Sold_Items_Inc_Input = {\n  sold_item_count?: InputMaybe<Scalars['bigint']>;\n};\n\n/** input type for inserting data into table \"sold_items\" */\nexport type Sold_Items_Insert_Input = {\n  inventory?: InputMaybe<Inventory_Obj_Rel_Insert_Input>;\n  item_id?: InputMaybe<Scalars['String']>;\n  sale_transaction?: InputMaybe<Sale_Transactions_Obj_Rel_Insert_Input>;\n  sold_item_count?: InputMaybe<Scalars['bigint']>;\n  transaction_id?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate max on columns */\nexport type Sold_Items_Max_Fields = {\n  __typename?: 'sold_items_max_fields';\n  item_id?: Maybe<Scalars['String']>;\n  sold_item_count?: Maybe<Scalars['bigint']>;\n  transaction_id?: Maybe<Scalars['String']>;\n};\n\n/** order by max() on columns of table \"sold_items\" */\nexport type Sold_Items_Max_Order_By = {\n  item_id?: InputMaybe<Order_By>;\n  sold_item_count?: InputMaybe<Order_By>;\n  transaction_id?: InputMaybe<Order_By>;\n};\n\n/** aggregate min on columns */\nexport type Sold_Items_Min_Fields = {\n  __typename?: 'sold_items_min_fields';\n  item_id?: Maybe<Scalars['String']>;\n  sold_item_count?: Maybe<Scalars['bigint']>;\n  transaction_id?: Maybe<Scalars['String']>;\n};\n\n/** order by min() on columns of table \"sold_items\" */\nexport type Sold_Items_Min_Order_By = {\n  item_id?: InputMaybe<Order_By>;\n  sold_item_count?: InputMaybe<Order_By>;\n  transaction_id?: InputMaybe<Order_By>;\n};\n\n/** response of any mutation on the table \"sold_items\" */\nexport type Sold_Items_Mutation_Response = {\n  __typename?: 'sold_items_mutation_response';\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars['Int'];\n  /** data from the rows affected by the mutation */\n  returning: Array<Sold_Items>;\n};\n\n/** on_conflict condition type for table \"sold_items\" */\nexport type Sold_Items_On_Conflict = {\n  constraint: Sold_Items_Constraint;\n  update_columns?: Array<Sold_Items_Update_Column>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n/** Ordering options when selecting data from \"sold_items\". */\nexport type Sold_Items_Order_By = {\n  inventory?: InputMaybe<Inventory_Order_By>;\n  item_id?: InputMaybe<Order_By>;\n  sale_transaction?: InputMaybe<Sale_Transactions_Order_By>;\n  sold_item_count?: InputMaybe<Order_By>;\n  transaction_id?: InputMaybe<Order_By>;\n};\n\n/** primary key columns input for table: sold_items */\nexport type Sold_Items_Pk_Columns_Input = {\n  sold_item_count: Scalars['bigint'];\n};\n\n/** select columns of table \"sold_items\" */\nexport type Sold_Items_Select_Column =\n  /** column name */\n  | 'item_id'\n  /** column name */\n  | 'sold_item_count'\n  /** column name */\n  | 'transaction_id';\n\n/** input type for updating data in table \"sold_items\" */\nexport type Sold_Items_Set_Input = {\n  item_id?: InputMaybe<Scalars['String']>;\n  sold_item_count?: InputMaybe<Scalars['bigint']>;\n  transaction_id?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate stddev on columns */\nexport type Sold_Items_Stddev_Fields = {\n  __typename?: 'sold_items_stddev_fields';\n  sold_item_count?: Maybe<Scalars['Float']>;\n};\n\n/** order by stddev() on columns of table \"sold_items\" */\nexport type Sold_Items_Stddev_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type Sold_Items_Stddev_Pop_Fields = {\n  __typename?: 'sold_items_stddev_pop_fields';\n  sold_item_count?: Maybe<Scalars['Float']>;\n};\n\n/** order by stddev_pop() on columns of table \"sold_items\" */\nexport type Sold_Items_Stddev_Pop_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type Sold_Items_Stddev_Samp_Fields = {\n  __typename?: 'sold_items_stddev_samp_fields';\n  sold_item_count?: Maybe<Scalars['Float']>;\n};\n\n/** order by stddev_samp() on columns of table \"sold_items\" */\nexport type Sold_Items_Stddev_Samp_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\n/** Streaming cursor of the table \"sold_items\" */\nexport type Sold_Items_Stream_Cursor_Input = {\n  /** Stream column input with initial value */\n  initial_value: Sold_Items_Stream_Cursor_Value_Input;\n  /** cursor ordering */\n  ordering?: InputMaybe<Cursor_Ordering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type Sold_Items_Stream_Cursor_Value_Input = {\n  item_id?: InputMaybe<Scalars['String']>;\n  sold_item_count?: InputMaybe<Scalars['bigint']>;\n  transaction_id?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate sum on columns */\nexport type Sold_Items_Sum_Fields = {\n  __typename?: 'sold_items_sum_fields';\n  sold_item_count?: Maybe<Scalars['bigint']>;\n};\n\n/** order by sum() on columns of table \"sold_items\" */\nexport type Sold_Items_Sum_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\n/** update columns of table \"sold_items\" */\nexport type Sold_Items_Update_Column =\n  /** column name */\n  | 'item_id'\n  /** column name */\n  | 'sold_item_count'\n  /** column name */\n  | 'transaction_id';\n\nexport type Sold_Items_Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<Sold_Items_Inc_Input>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<Sold_Items_Set_Input>;\n  /** filter the rows which have to be updated */\n  where: Sold_Items_Bool_Exp;\n};\n\n/** aggregate var_pop on columns */\nexport type Sold_Items_Var_Pop_Fields = {\n  __typename?: 'sold_items_var_pop_fields';\n  sold_item_count?: Maybe<Scalars['Float']>;\n};\n\n/** order by var_pop() on columns of table \"sold_items\" */\nexport type Sold_Items_Var_Pop_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\n/** aggregate var_samp on columns */\nexport type Sold_Items_Var_Samp_Fields = {\n  __typename?: 'sold_items_var_samp_fields';\n  sold_item_count?: Maybe<Scalars['Float']>;\n};\n\n/** order by var_samp() on columns of table \"sold_items\" */\nexport type Sold_Items_Var_Samp_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\n/** aggregate variance on columns */\nexport type Sold_Items_Variance_Fields = {\n  __typename?: 'sold_items_variance_fields';\n  sold_item_count?: Maybe<Scalars['Float']>;\n};\n\n/** order by variance() on columns of table \"sold_items\" */\nexport type Sold_Items_Variance_Order_By = {\n  sold_item_count?: InputMaybe<Order_By>;\n};\n\nexport type Subscription_Root = {\n  __typename?: 'subscription_root';\n  /** fetch data from the table: \"customers\" */\n  customers: Array<Customers>;\n  /** fetch aggregated fields from the table: \"customers\" */\n  customers_aggregate: Customers_Aggregate;\n  /** fetch data from the table: \"customers\" using primary key columns */\n  customers_by_pk?: Maybe<Customers>;\n  /** fetch data from the table in a streaming manner: \"customers\" */\n  customers_stream: Array<Customers>;\n  /** fetch data from the table: \"employees\" */\n  employees: Array<Employees>;\n  /** fetch aggregated fields from the table: \"employees\" */\n  employees_aggregate: Employees_Aggregate;\n  /** fetch data from the table: \"employees\" using primary key columns */\n  employees_by_pk?: Maybe<Employees>;\n  /** fetch data from the table in a streaming manner: \"employees\" */\n  employees_stream: Array<Employees>;\n  /** fetch data from the table: \"inventory\" */\n  inventory: Array<Inventory>;\n  /** fetch aggregated fields from the table: \"inventory\" */\n  inventory_aggregate: Inventory_Aggregate;\n  /** fetch data from the table: \"inventory\" using primary key columns */\n  inventory_by_pk?: Maybe<Inventory>;\n  /** fetch data from the table in a streaming manner: \"inventory\" */\n  inventory_stream: Array<Inventory>;\n  /** An array relationship */\n  sale_transactions: Array<Sale_Transactions>;\n  /** An aggregate relationship */\n  sale_transactions_aggregate: Sale_Transactions_Aggregate;\n  /** fetch data from the table: \"sale_transactions\" using primary key columns */\n  sale_transactions_by_pk?: Maybe<Sale_Transactions>;\n  /** fetch data from the table in a streaming manner: \"sale_transactions\" */\n  sale_transactions_stream: Array<Sale_Transactions>;\n  /** An array relationship */\n  sold_items: Array<Sold_Items>;\n  /** An aggregate relationship */\n  sold_items_aggregate: Sold_Items_Aggregate;\n  /** fetch data from the table: \"sold_items\" using primary key columns */\n  sold_items_by_pk?: Maybe<Sold_Items>;\n  /** fetch data from the table in a streaming manner: \"sold_items\" */\n  sold_items_stream: Array<Sold_Items>;\n};\n\n\nexport type Subscription_RootCustomersArgs = {\n  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Customers_Order_By>>;\n  where?: InputMaybe<Customers_Bool_Exp>;\n};\n\n\nexport type Subscription_RootCustomers_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Customers_Order_By>>;\n  where?: InputMaybe<Customers_Bool_Exp>;\n};\n\n\nexport type Subscription_RootCustomers_By_PkArgs = {\n  customer_id: Scalars['String'];\n};\n\n\nexport type Subscription_RootCustomers_StreamArgs = {\n  batch_size: Scalars['Int'];\n  cursor: Array<InputMaybe<Customers_Stream_Cursor_Input>>;\n  where?: InputMaybe<Customers_Bool_Exp>;\n};\n\n\nexport type Subscription_RootEmployeesArgs = {\n  distinct_on?: InputMaybe<Array<Employees_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Employees_Order_By>>;\n  where?: InputMaybe<Employees_Bool_Exp>;\n};\n\n\nexport type Subscription_RootEmployees_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Employees_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Employees_Order_By>>;\n  where?: InputMaybe<Employees_Bool_Exp>;\n};\n\n\nexport type Subscription_RootEmployees_By_PkArgs = {\n  employee_id: Scalars['String'];\n};\n\n\nexport type Subscription_RootEmployees_StreamArgs = {\n  batch_size: Scalars['Int'];\n  cursor: Array<InputMaybe<Employees_Stream_Cursor_Input>>;\n  where?: InputMaybe<Employees_Bool_Exp>;\n};\n\n\nexport type Subscription_RootInventoryArgs = {\n  distinct_on?: InputMaybe<Array<Inventory_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Inventory_Order_By>>;\n  where?: InputMaybe<Inventory_Bool_Exp>;\n};\n\n\nexport type Subscription_RootInventory_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Inventory_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Inventory_Order_By>>;\n  where?: InputMaybe<Inventory_Bool_Exp>;\n};\n\n\nexport type Subscription_RootInventory_By_PkArgs = {\n  item_id: Scalars['String'];\n};\n\n\nexport type Subscription_RootInventory_StreamArgs = {\n  batch_size: Scalars['Int'];\n  cursor: Array<InputMaybe<Inventory_Stream_Cursor_Input>>;\n  where?: InputMaybe<Inventory_Bool_Exp>;\n};\n\n\nexport type Subscription_RootSale_TransactionsArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n\nexport type Subscription_RootSale_Transactions_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sale_Transactions_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sale_Transactions_Order_By>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n\nexport type Subscription_RootSale_Transactions_By_PkArgs = {\n  transaction_id: Scalars['String'];\n};\n\n\nexport type Subscription_RootSale_Transactions_StreamArgs = {\n  batch_size: Scalars['Int'];\n  cursor: Array<InputMaybe<Sale_Transactions_Stream_Cursor_Input>>;\n  where?: InputMaybe<Sale_Transactions_Bool_Exp>;\n};\n\n\nexport type Subscription_RootSold_ItemsArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n\nexport type Subscription_RootSold_Items_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Sold_Items_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Sold_Items_Order_By>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\n\nexport type Subscription_RootSold_Items_By_PkArgs = {\n  sold_item_count: Scalars['bigint'];\n};\n\n\nexport type Subscription_RootSold_Items_StreamArgs = {\n  batch_size: Scalars['Int'];\n  cursor: Array<InputMaybe<Sold_Items_Stream_Cursor_Input>>;\n  where?: InputMaybe<Sold_Items_Bool_Exp>;\n};\n\nexport type MyMutationMutationVariables = Exact<{\n  customer_id?: InputMaybe<Scalars['String']>;\n  email_address?: InputMaybe<Scalars['String']>;\n  last_name?: InputMaybe<Scalars['String']>;\n  first_name?: InputMaybe<Scalars['String']>;\n}>;\n\n\nexport type MyMutationMutation = { __typename?: 'mutation_root', insert_customers_one?: { __typename?: 'customers', email_address?: string | null, first_name?: string | null, last_name?: string | null } | null };\n\nexport type DeleteCustomerByPkMutationVariables = Exact<{\n  customer_id: Scalars['String'];\n}>;\n\n\nexport type DeleteCustomerByPkMutation = { __typename?: 'mutation_root', delete_customers_by_pk?: { __typename?: 'customers', email_address?: string | null, first_name?: string | null, last_name?: string | null } | null };\n\nexport type GetCustomersLikeNameQueryVariables = Exact<{\n  limit?: InputMaybe<Scalars['Int']>;\n  first_name_term?: InputMaybe<Scalars['String']>;\n}>;\n\n\nexport type GetCustomersLikeNameQuery = { __typename?: 'query_root', customers: Array<{ __typename?: 'customers', email_address?: string | null, first_name?: string | null, last_name?: string | null }> };\n\n\nexport const MyMutationDocument = gql`\n    mutation MyMutation($customer_id: String, $email_address: String, $last_name: String, $first_name: String) {\n  insert_customers_one(\n    object: {email_address: $email_address, customer_id: $customer_id, last_name: $last_name, first_name: $first_name}\n  ) {\n    email_address\n    first_name\n    last_name\n  }\n}\n    `;\nexport type MyMutationMutationFn = Apollo.MutationFunction<MyMutationMutation, MyMutationMutationVariables>;\n\n/**\n * __useMyMutationMutation__\n *\n * To run a mutation, you first call `useMyMutationMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useMyMutationMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [myMutationMutation, { data, loading, error }] = useMyMutationMutation({\n *   variables: {\n *      customer_id: // value for 'customer_id'\n *      email_address: // value for 'email_address'\n *      last_name: // value for 'last_name'\n *      first_name: // value for 'first_name'\n *   },\n * });\n */\nexport function useMyMutationMutation(baseOptions?: Apollo.MutationHookOptions<MyMutationMutation, MyMutationMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<MyMutationMutation, MyMutationMutationVariables>(MyMutationDocument, options);\n      }\nexport type MyMutationMutationHookResult = ReturnType<typeof useMyMutationMutation>;\nexport type MyMutationMutationResult = Apollo.MutationResult<MyMutationMutation>;\nexport type MyMutationMutationOptions = Apollo.BaseMutationOptions<MyMutationMutation, MyMutationMutationVariables>;\nexport const DeleteCustomerByPkDocument: any = gql`\n    mutation DeleteCustomerByPK($customer_id: String!) {\n  delete_customers_by_pk(customer_id: $customer_id) {\n    email_address\n    first_name\n    last_name\n  }\n}\n    `;\nexport type DeleteCustomerByPkMutationFn = Apollo.MutationFunction<DeleteCustomerByPkMutation, DeleteCustomerByPkMutationVariables>;\n\n/**\n * __useDeleteCustomerByPkMutation__\n *\n * To run a mutation, you first call `useDeleteCustomerByPkMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteCustomerByPkMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteCustomerByPkMutation, { data, loading, error }] = useDeleteCustomerByPkMutation({\n *   variables: {\n *      customer_id: // value for 'customer_id'\n *   },\n * });\n */\nexport function useDeleteCustomerByPkMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCustomerByPkMutation, DeleteCustomerByPkMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<DeleteCustomerByPkMutation, DeleteCustomerByPkMutationVariables>(DeleteCustomerByPkDocument, options);\n      }\nexport type DeleteCustomerByPkMutationHookResult = ReturnType<typeof useDeleteCustomerByPkMutation>;\nexport type DeleteCustomerByPkMutationResult = Apollo.MutationResult<DeleteCustomerByPkMutation>;\nexport type DeleteCustomerByPkMutationOptions = Apollo.BaseMutationOptions<DeleteCustomerByPkMutation, DeleteCustomerByPkMutationVariables>;\nexport const GetCustomersLikeNameDocument = gql`\n    query GetCustomersLikeName($limit: Int, $first_name_term: String) {\n  customers(limit: $limit, where: {first_name: {_like: $first_name_term}}) {\n    email_address\n    first_name\n    last_name\n  }\n}\n    `;\n\n/**\n * __useGetCustomersLikeNameQuery__\n *\n * To run a query within a React component, call `useGetCustomersLikeNameQuery` and pass it any options that fit your needs.\n * When your component renders, `useGetCustomersLikeNameQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGetCustomersLikeNameQuery({\n *   variables: {\n *      limit: // value for 'limit'\n *      first_name_term: // value for 'first_name_term'\n *   },\n * });\n */\nexport function useGetCustomersLikeNameQuery(baseOptions?: Apollo.QueryHookOptions<GetCustomersLikeNameQuery, GetCustomersLikeNameQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<GetCustomersLikeNameQuery, GetCustomersLikeNameQueryVariables>(GetCustomersLikeNameDocument, options);\n      }\nexport function useGetCustomersLikeNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCustomersLikeNameQuery, GetCustomersLikeNameQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<GetCustomersLikeNameQuery, GetCustomersLikeNameQueryVariables>(GetCustomersLikeNameDocument, options);\n        }\nexport type GetCustomersLikeNameQueryHookResult = ReturnType<typeof useGetCustomersLikeNameQuery>;\nexport type GetCustomersLikeNameLazyQueryHookResult = ReturnType<typeof useGetCustomersLikeNameLazyQuery>;\nexport type GetCustomersLikeNameQueryResult = Apollo.QueryResult<GetCustomersLikeNameQuery, GetCustomersLikeNameQueryVariables>;"],"mappings":";;;;AAAA,SAASA,GAAG,QAAQ,gBAAgB;AACpC,OAAO,KAAKC,MAAM,MAAM,gBAAgB;AAMxC,MAAMC,cAAc,GAAG,CAAC,CAAU;AAClC;;AAqrEA,OAAO,MAAMC,kBAAkB,GAAGH,GAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,qBAAqB,CAACC,WAAyF,EAAE;EAAA;EACzH,MAAMC,OAAO,GAAG;IAAC,GAAGJ,cAAc;IAAE,GAAGG;EAAW,CAAC;EACnD,OAAOJ,MAAM,CAACM,WAAW,CAAkDJ,kBAAkB,EAAEG,OAAO,CAAC;AACzG;AAAC,GAHSF,qBAAqB;EAAA,QAEtBH,MAAM,CAACM,WAAW;AAAA;AAKjC,OAAO,MAAMC,0BAA+B,GAAGR,GAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,6BAA6B,CAACJ,WAAyG,EAAE;EAAA;EACjJ,MAAMC,OAAO,GAAG;IAAC,GAAGJ,cAAc;IAAE,GAAGG;EAAW,CAAC;EACnD,OAAOJ,MAAM,CAACM,WAAW,CAAkEC,0BAA0B,EAAEF,OAAO,CAAC;AACjI;AAAC,IAHSG,6BAA6B;EAAA,QAE9BR,MAAM,CAACM,WAAW;AAAA;AAKjC,OAAO,MAAMG,4BAA4B,GAAGV,GAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,4BAA4B,CAACN,WAAoG,EAAE;EAAA;EAC3I,MAAMC,OAAO,GAAG;IAAC,GAAGJ,cAAc;IAAE,GAAGG;EAAW,CAAC;EACnD,OAAOJ,MAAM,CAACW,QAAQ,CAAgEF,4BAA4B,EAAEJ,OAAO,CAAC;AAC9H;AAAC,IAHSK,4BAA4B;EAAA,QAE7BV,MAAM,CAACW,QAAQ;AAAA;AAE9B,OAAO,SAASC,gCAAgC,CAACR,WAAwG,EAAE;EAAA;EACjJ,MAAMC,OAAO,GAAG;IAAC,GAAGJ,cAAc;IAAE,GAAGG;EAAW,CAAC;EACnD,OAAOJ,MAAM,CAACa,YAAY,CAAgEJ,4BAA4B,EAAEJ,OAAO,CAAC;AAClI;AAAC,IAHOO,gCAAgC;EAAA,QAE/BZ,MAAM,CAACa,YAAY;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}